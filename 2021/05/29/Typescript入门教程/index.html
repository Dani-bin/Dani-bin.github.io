<!DOCTYPE html>


<html lang="zh-Hans">
  

    <head>
      <meta charset="utf-8" />
       
      <meta name="keywords" content="纸片人" />
       
      <meta name="description" content="纸片人的个人博客" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Typescript入门教程 |  彬</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <!-- mermaid -->
      
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Typescript入门教程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Typescript入门教程
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/05/29/Typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" class="article-date">
  <time datetime="2021-05-29T13:20:28.892Z" itemprop="datePublished">2021-05-29</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">3.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">15 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Typescript入门教程"><a href="#Typescript入门教程" class="headerlink" title="Typescript入门教程"></a>Typescript入门教程</h1><p><strong>Typescript是什么</strong></p>
<blockquote>
<p>TypeScript是JavaScript类型的超集，它可以编译成纯JavaScript。TypeScript可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。</p>
</blockquote>
<p>TypeScript 是由微软公司在 2012 年正式发布,TypeScript就是JavaScript 的超集，也就是说 TypeScript 是建立在 JavaScript 之上的，最后都会转变成 JavaScript。</p>
<span id="more"></span>

<h2 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h2><p><strong>布尔值</strong></p>
<pre><code>let isBoolean: boolean = true
</code></pre>
<p><strong>数字</strong></p>
<pre><code>let decLiteral: number = 6;
let notANumber: number = NaN;
let infinityNumber: number = Infinity;
</code></pre>
<p><strong>字符串</strong></p>
<pre><code>let myName: string = &#39;Tom&#39;;
let sentence: string = `Hello, my name is $&#123;myName&#125;.
I&#39;ll be $&#123;myAge + 1&#125; years old next month.`;
</code></pre>
<p><strong>空值</strong></p>
<p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数</p>
<pre><code>function alertName(name: string): void &#123;
  window.alert(name)
&#125;
alertName(&#39;bin&#39;)
</code></pre>
<p><strong>Null 和 Undefined</strong></p>
<p>与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量</p>
<pre><code>let u: undefined = undefined;
let n: null = null;

let u: void;
let num: number = u;
// Type &#39;void&#39; is not assignable to type &#39;number&#39;.
</code></pre>
<h2 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h2><p>任意值（Any）用来表示允许赋值为任意类型。</p>
<pre><code>let myFavoriteNumber: any = &#39;seven&#39;;
myFavoriteNumber = 7;
</code></pre>
<p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：</p>
<pre><code>let something;
</code></pre>
<p>等价于：<br>    let something: any;</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li><p>使用「类型 + 方括号」来表示数组</p>
<p> let list: number[] = [1, 1, 2, 3, 5];</p>
</li>
<li><p>使用数组泛型 Array<elemType> 来表示数组</p>
<p> let list: Array<number> = [1, 2, 3];</p>
</li>
</ol>
<p>数组定义的时候，就规定了每个元素的类型，如果不是规定的类型，就会报错</p>
<pre><code>let list: number[] = [1, &#39;string&#39;, 2, 3, 5];
// Type &#39;string&#39; is not assignable to type &#39;number&#39;.
</code></pre>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。</p>
<p>定义一对值分别为 string 和 number 的元组：</p>
<pre><code>let tom: [string, number] = [&#39;Tom&#39;, 25];
</code></pre>
<p>当赋值或访问一个已知索引的元素时，会得到正确的类型：</p>
<pre><code>let tom: [string, number];
tom[0] = &#39;Tom&#39;;
tom[1] = 25;

//对应存在的方法
tom[0].slice(1);  
tom[1].toFixed(2);
</code></pre>
<p>也可以只赋值其中一项：</p>
<pre><code>let tom: [string, number];
tom[0] = &#39;Tom&#39;;
</code></pre>
<p>但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。</p>
<pre><code>let tom: [string, number];
tom = [&#39;Tom&#39;, 25];

let tom: [string, number];
tom = [&#39;Tom&#39;];
// Property &#39;1&#39; is missing in type &#39;[string]&#39; but required in type &#39;[string, number]&#39;.
</code></pre>
<p>当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型：</p>
<pre><code>let tom: [string, number];
tom = [&#39;Tom&#39;, 25];
tom.push(&#39;male&#39;);
tom.push(true);
// Argument of type &#39;true&#39; is not assignable to parameter of type &#39;string | number&#39;.
</code></pre>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>enum类型是对JavaScript标准数据类型的一个补充。用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p>
<p>枚举使用 enum 关键字来定义：</p>
<pre><code>enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;
</code></pre>
<p>枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：</p>
<pre><code>enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;

console.log(Days[&quot;Sun&quot;] === 0); // true
console.log(Days[&quot;Mon&quot;] === 1); // true
console.log(Days[&quot;Tue&quot;] === 2); // true
console.log(Days[&quot;Sat&quot;] === 6); // true

console.log(Days[0] === &quot;Sun&quot;); // true
console.log(Days[1] === &quot;Mon&quot;); // true
console.log(Days[2] === &quot;Tue&quot;); // true
console.log(Days[6] === &quot;Sat&quot;); // true
</code></pre>
<p>给枚举项手动赋值：</p>
<pre><code>enum Days &#123;Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;

console.log(Days[&quot;Sun&quot;] === 7); // true
console.log(Days[&quot;Mon&quot;] === 1); // true

// 未手动赋值的枚举项会接着上一个枚举项递增。
console.log(Days[&quot;Tue&quot;] === 2); // true
console.log(Days[&quot;Sat&quot;] === 6); // true
</code></pre>
<h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p>never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。</p>
<p>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。</p>
<pre><code>// 返回never的函数必须存在无法达到的终点
function error(message: string): never &#123;
    throw new Error(message);
&#125;

// 推断的返回值类型为never
function fail() &#123;
    return error(&quot;Something failed&quot;);
&#125;

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never &#123;
    while (true) &#123;
    &#125;
&#125;
</code></pre>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。<br>使用object类型，就可以更好的表示像Object.create这样的API。例如：</p>
<pre><code>declare function create(o: object | null): void;

create(&#123; prop: 0 &#125;); // OK
create(null); // OK

create(42); // Error
create(&quot;string&quot;); // Error
create(false); // Error
create(undefined); // Error
</code></pre>
<h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论的规则推断出一个类型。</p>
<p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p>
<pre><code>let myFavoriteNumber = &#39;seven&#39;;
myFavoriteNumber = 7;

// index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.
</code></pre>
<p>事实上，它等价于：</p>
<pre><code>let myFavoriteNumber: string = &#39;seven&#39;;
myFavoriteNumber = 7;

// index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.
</code></pre>
<p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p>
<p>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：</p>
<pre><code>let myFavoriteNumber;
myFavoriteNumber = &#39;seven&#39;;
myFavoriteNumber = 7;
</code></pre>
<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p>
<p>联合类型使用 | 分隔每个类型。</p>
<pre><code>let myFavoriteNumber: string | number;
myFavoriteNumber = &#39;seven&#39;;
myFavoriteNumber = 7;

let myFavoriteNumber: string | number;
myFavoriteNumber = true;

// index.ts(2,1): error TS2322: Type &#39;boolean&#39; is not assignable to type &#39;string | number&#39;.
// Type &#39;boolean&#39; is not assignable to type &#39;number&#39;.
</code></pre>
<p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：</p>
<pre><code>function getLength(something: string | number): number &#123;
    return something.length;
&#125;

// index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.
// Property &#39;length&#39; does not exist on type &#39;number&#39;.
</code></pre>
<p>访问 string 和 number 的共有属性是没问题的：</p>
<pre><code>function getString(something: string | number): string &#123;
    return something.toString();
&#125;
</code></pre>
<h2 id="对象的类型——接口"><a href="#对象的类型——接口" class="headerlink" title="对象的类型——接口"></a>对象的类型——接口</h2><p>使用接口（Interfaces）来定义对象的类型。</p>
<pre><code>// 接口一般首字母大写。
interface Person &#123;
    name: string;
    age: number;
&#125;

let tom: Person = &#123;
    name: &#39;Tom&#39;,
    age: 25
&#125;;
</code></pre>
<p>定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致。</p>
<p>赋值的时候，变量的形状必须和接口的形状保持一致。</p>
<p>定义的变量比接口少了一些属性是不允许的：</p>
<pre><code>interface Person &#123;
    name: string;
    age: number;
&#125;

let tom: Person = &#123;
    name: &#39;Tom&#39;
&#125;;

// index.ts(6,5): error TS2322: Type &#39;&#123; name: string; &#125;&#39; is not assignable to type &#39;Person&#39;.
// Property &#39;age&#39; is missing in type &#39;&#123; name: string; &#125;&#39;.
</code></pre>
<p>多一些属性也是不允许的：</p>
<pre><code>interface Person &#123;
    name: string;
    age: number;
&#125;

let tom: Person = &#123;
    name: &#39;Tom&#39;,
    age: 25,
    gender: &#39;male&#39;
&#125;;

// index.ts(9,5): error TS2322: Type &#39;&#123; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.
// Object literal may only specify known properties, and &#39;gender&#39; does not exist in type &#39;Person&#39;.
</code></pre>
<p><strong>可选属性</strong></p>
<p>有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p>
<pre><code>interface Person &#123;
    name: string;
    age?: number;
&#125;

let tom: Person = &#123;
    name: &#39;Tom&#39;
&#125;;
</code></pre>
<p>或者：</p>
<pre><code>interface Person &#123;
    name: string;
    age?: number;
&#125;

let tom: Person = &#123;
    name: &#39;Tom&#39;,
    age: 25
&#125;;
</code></pre>
<p>这时仍然不允许添加未定义的属性：</p>
<pre><code>interface Person &#123;
    name: string;
    age?: number;
&#125;

let tom: Person = &#123;
    name: &#39;Tom&#39;,
    age: 25,
    gender: &#39;male&#39;
&#125;;

// examples/playground/index.ts(9,5): error TS2322: Type &#39;&#123; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.
// Object literal may only specify known properties, and &#39;gender&#39; does not exist in type &#39;Person&#39;.
</code></pre>
<p><strong>任意属性</strong></p>
<p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p>
<pre><code>interface Person &#123;
    name: string;
    age?: number;
    [propName: string]: any;
&#125;

let tom: Person = &#123;
    name: &#39;Tom&#39;,
    gender: &#39;male&#39;
&#125;;
</code></pre>
<p>使用 [propName: string] 定义了任意属性取 string 类型的值。</p>
<p>需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：</p>
<pre><code>interface Person &#123;
    name: string;
    age?: number;
    [propName: string]: string;
&#125;

let tom: Person = &#123;
    name: &#39;Tom&#39;,
    age: 25,
    gender: &#39;male&#39;
&#125;;

// index.ts(3,5): error TS2411: Property &#39;age&#39; of type &#39;number&#39; is not assignable to string index type &#39;string&#39;.
// index.ts(7,5): error TS2322: Type &#39;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#39; is not assignable to type &#39;Person&#39;.
// Index signatures are incompatible.
// Type &#39;string | number&#39; is not assignable to type &#39;string&#39;.
// Type &#39;number&#39; is not assignable to type &#39;string&#39;.
</code></pre>
<p>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：</p>
<pre><code>interface Person &#123;
    name: string;
    age?: number;
    [propName: string]: string | number;
&#125;

let tom: Person = &#123;
    name: &#39;Tom&#39;,
    age: 25,
    gender: &#39;male&#39;
&#125;;
</code></pre>
<p><strong>只读属性</strong></p>
<p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性：</p>
<pre><code>interface Person &#123;
    readonly id: number;
    name: string;
    age?: number;
    [propName: string]: any;
&#125;

let tom: Person = &#123;
    id: 89757,
    name: &#39;Tom&#39;,
    gender: &#39;male&#39;
&#125;;

tom.id = 9527;

// index.ts(14,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.
</code></pre>
<p>上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。</p>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名用来给一个类型起个新名字。类型别名常用于联合类型。</p>
<pre><code>type Name = string;
type NameResolver = () =&gt; string;
type NameOrResolver = Name | NameResolver;
function getName(n: NameOrResolver): Name &#123;
    if (typeof n === &#39;string&#39;) &#123;
        return n;
    &#125; else &#123;
        return n();
    &#125;
&#125;
</code></pre>
<h2 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h2><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个。</p>
<pre><code>type EventNames = &#39;click&#39; | &#39;scroll&#39; | &#39;mousemove&#39;;
function handleEvent(ele: Element, event: EventNames) &#123;
    // do something
&#125;

handleEvent(document.getElementById(&#39;hello&#39;), &#39;scroll&#39;);  // 没问题
handleEvent(document.getElementById(&#39;world&#39;), &#39;dblclick&#39;); // 报错，event 不能为 &#39;dblclick&#39;

// index.ts(7,47): error TS2345: Argument of type &#39;&quot;dblclick&quot;&#39; is not assignable to parameter of type &#39;EventNames&#39;.
</code></pre>
<p>上例中，我们使用 type 定了一个字符串字面量类型 EventNames，它只能取三种字符串中的一种。</p>
<p>注意，类型别名与字符串字面量类型都是使用 type 进行定义。</p>
<h2 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h2><p><strong>函数声明</strong></p>
<p>一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：</p>
<pre><code>function sum(x: number, y: number): number &#123;
    return x + y;
&#125;
</code></pre>
<p>输入多余的（或者少于要求的）参数，是不被允许的：</p>
<pre><code>function sum(x: number, y: number): number &#123;
    return x + y;
&#125;
sum(1, 2, 3);
 // index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.

function sum(x: number, y: number): number &#123;
    return x + y;
&#125;
sum(1);
 // index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.
</code></pre>
<p><strong>函数表达式</strong></p>
<p>如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样：</p>
<pre><code>let mySum = function (x: number, y: number): number &#123;
    return x + y;
&#125;;
</code></pre>
<p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样：</p>
<pre><code>let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123;
    return x + y;
&#125;;
</code></pre>
<p>注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。</p>
<p>在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p>
<p><strong>用接口定义函数的形状</strong></p>
<p>我们也可以使用接口的方式来定义一个函数需要符合的形状：</p>
<pre><code>interface SearchFunc &#123;
    (source: string, subString: string): boolean;
&#125;

let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) &#123;
    return source.search(subString) !== -1;
&#125;
</code></pre>
<p>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p>
<p><strong>可选参数</strong></p>
<p>与接口中的可选属性类似，我们用 ? 表示可选的参数：</p>
<pre><code>function buildName(firstName: string, lastName?: string) &#123;
    if (lastName) &#123;
        return firstName + &#39; &#39; + lastName;
    &#125; else &#123;
        return firstName;
    &#125;
&#125;
let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);
let tom = buildName(&#39;Tom&#39;);
</code></pre>
<p>需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了</p>
<pre><code>function buildName(firstName?: string, lastName: string) &#123;
    if (firstName) &#123;
        return firstName + &#39; &#39; + lastName;
    &#125; else &#123;
        return lastName;
    &#125;
&#125;
let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);
let tom = buildName(undefined, &#39;Tom&#39;);

// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.
</code></pre>
<p><strong>参数默认值</strong></p>
<p>在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数：</p>
<pre><code>function buildName(firstName: string, lastName: string = &#39;Cat&#39;) &#123;
    return firstName + &#39; &#39; + lastName;
&#125;
let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);
let tom = buildName(&#39;Tom&#39;);
</code></pre>
<p>此时就不受「可选参数必须接在必需参数后面」的限制了：</p>
<pre><code>function buildName(firstName: string = &#39;Tom&#39;, lastName: string) &#123;
    return firstName + &#39; &#39; + lastName;
&#125;
let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);
let cat = buildName(undefined, &#39;Cat&#39;);
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2021/05/29/Typescript%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "",
    app_key: "",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> 纸片人
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="彬"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=28285910&auto=1&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>